package com.msft.stardust.model.resources

import com.msft.stardust.*
import com.msft.stardust.model.StardustDocument

private val animatorsFilePath = global_projectSourcePath.plus("main/java/com/microsoft/stardust/Animators.kt")

fun generateAnimators(document: StardustDocument) {
    val generator = AnimatorGenerator()
    document.filter { it.key.startsWith(ANIMATOR_PREFIX) }.forEach {
        it.value.forEach { animator ->
            generator.generateAnimator(animator.key, animator.value as LinkedHashMap<*, *>)
        }
    }
    if (global_documentType == DocumentType.ROOT) generator.generateAnimatorEnum()
}

class AnimatorGenerator {
    private val animatorList = mutableSetOf<String>()

    fun generateAnimator(name: String, values: LinkedHashMap<*, *>) {
        generateAnimatorInternal(name, values, false)
        if (values.contains("curve")) {
            // generate v21 version, for interpolator support
            generateAnimatorInternal(name, values, true)
        }
    }

    private fun generateAnimatorInternal(name: String, values: LinkedHashMap<*, *>, v21: Boolean) {
        StringBuilder().apply {
            append(AUTOGENERATED_XML_HEADER)
            append("<objectAnimator xmlns:android=\"http://schemas.android.com/apk/res/android\"\n")
            values.forEach { animatorValue ->
                append(when (animatorValue.key) {
                    "curve" -> if (v21) "\tandroid:interpolator=\"${animatorValue.value.toString().resolveResourceReference(ResourceType.ANIMATION)}\"\n" else "" // interpolator needs >= v21
                    "keyFrames" -> parseKeyFrames(animatorValue.value as List<*>)
                    "repeatCount" -> "\tandroid:repeatCount=\"${animatorValue.value}\"\n"
                    "duration" -> "\tandroid:duration=\"${animatorValue.value.toString().resolveResourceReference(ResourceType.INTEGER)}\"\n"
                    "delay" -> "\tandroid:startOffset=\"${animatorValue.value.toString().resolveResourceReference(ResourceType.INTEGER)}\"\n"
                    else -> {
                        printError("Unknown animator value \"${animatorValue.key}\""); ""
                    }
                })
            }
            append("/>")
            toString().writeToResourceFile(global_flavorPath.plus("res/animator${if (v21) "-v21" else ""}/${name.toLowerCase()}.xml"), "Animator")
            animatorList.add(name)
        }
    }

    fun generateAnimatorEnum() {
        StringBuilder().apply {
            append(AUTOGENERATED_CODE_HEADER)
            append("\npackage com.microsoft.stardust\n\n")
            append("enum class StardustAnimator ")
            append(animatorList.joinToString(separator = ", ", prefix = "{", postfix = "}", transform = { it.toUpperCase() }))
            toString().writeToResourceFile(animatorsFilePath, "animators enum file")
        }
    }
}

private fun parseKeyFrames(values: List<*>): String =
        StringBuilder().run {
            values.forEach {
                (it as LinkedHashMap<*, *>).forEach { keyFrame ->
                    when (keyFrame.key) {
                        "relativeStartTime" -> Unit // unsupported on Android
                        "animationValues" -> {
                            (keyFrame.value as List<*>).forEach {
                                (it as LinkedHashMap<*, *>).forEach { animationValue ->
                                    when (animationValue.key) {
                                        "type" -> append(
                                                "\tandroid:propertyName=\"" + when (animationValue.value) {
                                                    "alpha" -> "alpha"
                                                    "rotate" -> "rotation"
                                                    "color" -> "color"
                                                    "scale" -> "scaleX" //TODO: generate animator set to scale both X and Y
                                                    // TODO: add support for other animation types
                                                    else -> {
                                                        printError("Unknown animation type \"${animationValue.value}\""); ""
                                                    }
                                                } + "\"\n"
                                        )
                                        "from" -> append("\tandroid:valueFrom=\"${animationValue.value.toString().autoResolveReference()}\"\n")
                                        "to" -> append("\tandroid:valueTo=\"${animationValue.value.toString().autoResolveReference()}\"\n")
                                        else -> printWarning("Unknown animation value \"${animationValue.key}\"")
                                    }
                                }
                            }
                        }
                    }
                }
            }
            toString()
        }