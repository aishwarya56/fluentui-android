package microsoft.fluentui.generator.model.resources

import microsoft.fluentui.generator.*
import microsoft.fluentui.generator.model.global_getResourceType
import java.util.*

enum class ResourceType(
    val resourceName: String,
    val unit: String = "",
    val resNameIsLowercase: Boolean = false,
    val className: String? = null
) {
    ANIMATION("anim", resNameIsLowercase = true),
    BOOLEAN("bool"),
    COLOR("color"),
    DIMENSION("dimen", "dp"),
    FLOAT("float"),
    INTEGER("integer", className = "Int"),
    ENUM("enum", className = "Enum"),
    STRING("string", className = "String"),
    STYLE("style"),
    TYPED_ARRAY("array"),
    TYPOGRAPHY("dimen", "sp")
}

// Simple data class
data class Resource(
        val name: String,
        val value: String,
        val type: ResourceType,
        val resourceList: List<Resource>? = null,
        val forNightTheme: Boolean = false
)

fun generateResources(
        flavorPath: String,
        name: String,
        values: List<Resource>,
        prependNameToResourceName: Boolean = false,
        ignoreDocumentTypeIdentifier: Boolean = false
) {
    if (values.isEmpty()) {
        println("Empty resources list for \"$name\"")
    } else {
        // Partition the resources based on the forNightTheme flag.
        val (default, night) = values.partition { !it.forNightTheme }
        listOf(default, night).forEachIndexed { index, list ->
            if (list.isEmpty()) return@forEachIndexed

            val forNightTheme = index == 1
            StringBuilder().apply {
                append(AUTOGENERATED_XML_HEADER)
                append("<resources>\n")

                intGenerateResources(this, name, list, prependNameToResourceName, false)

                append("</resources>")

                toString().writeToResourceFile(
                    flavorPath.plus("res/values${if (!ignoreDocumentTypeIdentifier) global_documentType.identifierString(forNightTheme) else ""}/${name}_res.autogenerated.xml"),
                    "${list.count()} resources"
                )
            }
        }
    }
}

fun intGenerateResources(
        stringBuilder: StringBuilder,
        name: String,
        values: List<Resource>,
        prependNameToResourceName: Boolean = false,
        isTypedArrayItem: Boolean = false
) {
    values.forEach {
        with(stringBuilder) {
            if (it.type == ResourceType.TYPED_ARRAY) {
                when {
                    it.name.isBlank() -> printError("Found typed array resource with no name!")
                    it.resourceList  == null || it.resourceList.isEmpty() -> printError("Found typed array resource with no vakues!")
                    else -> {
                        append("\t<array name=\"${it.name}\">\n")

                        intGenerateResources(stringBuilder, name, it.resourceList, prependNameToResourceName, true)

                        append("\t</array>\n")
                    }
                }
            } else when {
                it.name.isBlank() -> printError("Found resource with no name!")
                it.value.isBlank() -> printError("No value specified for resource \"${it.name}\"!")
                it.type == ResourceType.STYLE -> append("\t<${it.type.resourceName} parent=\"${it.value}\" name=\"${if (prependNameToResourceName) "${name}_" else ""}${it.name}\"/>\n")
                it.type == ResourceType.FLOAT -> append("\t<item name=\"${if (prependNameToResourceName) "${name}_" else ""}${it.name}\" format=\"${it.type.resourceName}\" type=\"dimen\">${it.value}</item>\n")
                isTypedArrayItem -> append("\t\t<item>${it.value}${if (it.value.toIntOrNull() != null) it.type.unit else ""}</item>\n")
                else -> append("\t<${it.type.resourceName} name=\"${if (prependNameToResourceName) "${name}_" else ""}${it.name}\">${it.value}${if (it.value.toIntOrNull() != null) it.type.unit else ""}</${it.type.resourceName}>\n")
            }
        }
    }
}

fun generateComponentProxyFile(
        flavorPath: String,
        stylesheetName: String,
        viewName: String,
        values: List<Resource>,
        parentName: String? = null,
        parentParameters: LinkedHashMap<String, Any>?
) {
    if (values.isEmpty()) {
        println("Empty resources list for \"$stylesheetName\"")
    } else {
        StringBuilder().apply {
            append(AUTOGENERATED_CODE_HEADER)
            append("package microsoft.fluentui.generator.resourceProxies")
            append(NEW_LINE)
            append(createGenericImports())
            append(NEW_LINE)

            append("open class $stylesheetName" + "Proxy(context: Context, resources: Resources)")
            parentName?.let {
                append(" : $it" + "Proxy(context, resources)")
            } ?: append(" : GenericProxy(context, resources)")
            append(" {\n")
            values.forEach {
                when {
                    it.name.isBlank() -> printError("Found resource with no name!")
                    it.value.isBlank() -> printError("No value specified for resource \"${it.name}\"!")
                    it.type == ResourceType.INTEGER -> append(
                        createIntegerVal(
                            viewName,
                            parentParameters,
                            it
                        )
                    )
                    it.type == ResourceType.COLOR -> append(
                        createColorVal(
                            viewName,
                            parentParameters,
                            it
                        )
                    )
                    it.type == ResourceType.DIMENSION -> append(
                        createDimensionVal(
                            viewName,
                            parentParameters,
                            it
                        )
                    )
                    it.type == ResourceType.ENUM -> append(
                        createEnumVal(
                            viewName,
                            parentParameters,
                            it
                        )
                    )
                    it.type == ResourceType.STYLE -> append(
                        createStyleVal(
                            viewName,
                            parentParameters,
                            it
                        )
                    )
                    it.type == ResourceType.FLOAT -> append(
                        createFloatVal(
                            viewName,
                            parentParameters,
                            it
                        )
                    )
                    it.type == ResourceType.BOOLEAN -> append(
                        createBooleanVal(
                            viewName,
                            parentParameters,
                            it
                        )
                    )
                }
            }

            append("}")

            toString().writeToKotlinFile(
                flavorPath,
                "${values.count()} resources"
            )
        }
    }
}

fun createBooleanVal(
    name: String,
    parentParameters: java.util.LinkedHashMap<String, Any>?,
    resource: Resource
): String {
    val prefix = parentParameters?.let {
        if (it.containsKey(resource.name.substringBefore("_"))) OVERRIDE_VAL_PREFIX else OPEN_VAL_PREFIX
    } ?: OPEN_VAL_PREFIX
    return prefix + resource.name + ": Boolean = resources.getBoolean(R.bool.${name.toLowerCase(
        Locale.ENGLISH
    )}_" + resource.name + ")\n"
}

fun createStyleVal(
    name: String,
    parentParameters: LinkedHashMap<String, Any>?,
    resource: Resource
): String {
    val prefix = parentParameters?.let {
        if (it.containsKey(resource.name.substringBefore("_"))) OVERRIDE_VAL_PREFIX else OPEN_VAL_PREFIX
    } ?: OPEN_VAL_PREFIX
    return prefix + resource.name + ": Int = R.style.${name.toLowerCase(Locale.ENGLISH)}_" + resource.name + "\n"
}

// FIXME: Combine with dimension?
fun createFloatVal(
    name: String,
    parentParameters: LinkedHashMap<String, Any>?,
    resource: Resource
): String? {
    val prefix = parentParameters?.let {
        if (it.containsKey(resource.name.substringBefore("_"))) OVERRIDE_VAL_PREFIX else OPEN_VAL_PREFIX
    } ?: OPEN_VAL_PREFIX
    return prefix + resource.name + ": Float = TypedValue().also { v -> resources.getValue(R.dimen." + "${name.toLowerCase(
        Locale.ENGLISH
    )}_" + resource.name + ", v, true) }.float\n"
}

fun createDimensionVal(
    name: String,
    parentParameters: LinkedHashMap<String, Any>?,
    resource: Resource
): String? {
    val prefix = parentParameters?.let {
        if (it.containsKey(resource.name.substringBefore("_"))) OVERRIDE_VAL_PREFIX else OPEN_VAL_PREFIX
    } ?: OPEN_VAL_PREFIX
    return prefix + resource.name + ": Float" + " = resources.getDimension(R.dimen." + "${name.toLowerCase(
        Locale.ENGLISH
    )}_" + resource.name + ")\n"
}

// FIXME: name argument is not used?
fun createEnumVal(
    name: String,
    parentParameters: LinkedHashMap<String, Any>?,
    resource: Resource
): String? {
    val enumClassName = "microsoft.fluentui.generator" + resource.value.enumClassName()
    val prefix = parentParameters?.let {
        if (it.containsKey(resource.name.substringBefore("_"))) OVERRIDE_VAL_PREFIX else OPEN_VAL_PREFIX
    } ?: OPEN_VAL_PREFIX
    return prefix + resource.name + ": $enumClassName = $enumClassName.fromValue(resources.getInteger(" + resource.value + "))!!\n"
}

fun createIntegerVal(
    name: String,
    parentParameters: LinkedHashMap<String, Any>?,
    resource: Resource
): String {
    val prefix = parentParameters?.let {
        if (it.containsKey(resource.name.substringBefore("_"))) OVERRIDE_VAL_PREFIX else OPEN_VAL_PREFIX
    } ?: OPEN_VAL_PREFIX
    return prefix + resource.name + ": " + resource.type.className + " = resources.getInteger(R.integer." + "${name.toLowerCase(
        Locale.ENGLISH
    )}_" + resource.name + ")\n"
}

fun createColorVal(
    name: String,
    parentParameters: LinkedHashMap<String, Any>?,
    resource: Resource
): String {
    val prefix = parentParameters?.let {
        if (it.containsKey(resource.name.substringBefore("_"))) OVERRIDE_VAL_PREFIX else OPEN_VAL_PREFIX
    } ?: OPEN_VAL_PREFIX
    return prefix + resource.name + ": Int" + " = ContextCompat.getColor(context, R.color." + "${name.toLowerCase(
        Locale.ENGLISH
    )}_" + resource.name + ")\n"
}

fun createGenericImports(): String {
    return "\nimport android.content.Context\n" +
            "import android.util.TypedValue\n" +
            "import android.content.res.Resources\n" +
            "import android.support.v4.content.ContextCompat\n" +
            "import com.microsoft.fluentui.R\n"
}

// Parsing functions

// Android does not support multiple border width for the same drawable, so we just pick the first value of the map
// ie values = [normal: 1, active: 1, activeDisabled: 1, hover: 1, focus: 1, disabled: 1]
fun parseBorderWidth(values: Any?): String? =
    if (values is ArrayList<*> && values.isNotEmpty()) {
        when (val borderWidthValueEntry = values.first()) {
            is LinkedHashMap<*, *> -> borderWidthValueEntry.values.single().toString()
            else -> null
        }
    } else null


enum class CompositePrimitiveType(
    val pattern: String,
    val mask: List<String>,
    val contentPattern: String,
    val resourceType: ResourceType
) {
    ICON("^Icon\\(.*\\)\$", listOf("iconName"), STRING_PATTERN, ResourceType.STRING),
    INSETS(
        "^Insets\\(.*\\)\$",
        listOf("top", "start", "bottom", "end"),
        DIGITS_PATTERN,
            ResourceType.DIMENSION
    ),
    SIZE("^Size\\(.*\\)\$", listOf("width", "height"), DIGITS_PATTERN, ResourceType.DIMENSION),
    RECT(
        "^Rect\\(.*\\)\$",
        listOf("x", "y", "width", "height"),
        DIGITS_PATTERN,
            ResourceType.DIMENSION
    ),
    FLUENTUICOLOR("^FluentUIColor\\(.*\\)\$", listOf(""), STRING_PATTERN, ResourceType.COLOR),
    NAMEDCOLOR("^NamedColor\\(.*\\)\$", listOf(""), STRING_PATTERN, ResourceType.COLOR),
    FONT("^Font\\(.*\\)\$", listOf("size", "weight"), STRING_PATTERN, ResourceType.TYPOGRAPHY)
}

const val DIGITS_PATTERN = "-?\\d+\\.?\\d*"
const val STRING_PATTERN = "(?<=\\().+?(?=\\))"
const val RESOURCE_EXPRESSION_PATTERN = "^\\s*([^=><! ]+)\\s*(=|>|<|<=|>=|!=)\\s*([^=><! ]+)\\s*$"
const val FONT_PATTERN = "^Font\\(.*\\)\$"

@Suppress("unused")
fun parseResource(resourceList: MutableList<Resource>, resKey: String, values: Any?, index: Int? = null) {
    if (resKey.isValidKey()) {
        when (values) {
            is ArrayList<*> -> {
                // Look ahead at the first value.
                // If it is a string include an index when parsing this array.
                // TODO: Create a typed resource array instead of a numbered list.
                if (values[0] is String) {
                    // Collect all of the resources
                    val arrayResources: MutableList<Resource> = mutableListOf()
                    values.forEachIndexed { i, v ->
                        parseResource(arrayResources, resKey, v, i)
                    }

                    resourceList.add(Resource(
                        resKey,
                        "",
                        ResourceType.TYPED_ARRAY,
                        arrayResources
                    ))
                } else {
                    values.forEach { v -> parseResource(resourceList, resKey, v) }
                }
            }
            is LinkedHashMap<*, *> -> {
                // check if the key is an compile-time expression modifier
                val expressions = values.filter { isResourceExpressionModifier(it.key.toString()) }
                if (expressions.isNotEmpty()) {
                    if (!values.containsKey("default")) {
                        error("When using compile-time expressions, default value must be provided")
                    }
                    var resolvedValue = values["default"]
                    expressions.forEach {
                        if (resolveResourceExpression(it.key.toString())) {
                            resolvedValue = it.value
                        }
                    }
                    parseResource(resourceList, resKey, resolvedValue)
                } else {
                    values.forEach { parseResource(resourceList, "${resKey}_${it.key}", it.value) }
                }
            }
            is String -> {
                val resolvedResKey = if (index != null) "$resKey${index}" else resKey
                val resolvedReference = values.autoResolveReference()
                when {
                    values.isValidFloat() -> resourceList.add(
                        Resource(
                            resolvedResKey,
                            values.rawValue(),
                            ResourceType.FLOAT
                        )
                    )
                    values.isValidDimension() -> resourceList.add(
                        Resource(
                            resolvedResKey,
                            values.rawValue(),
                            ResourceType.DIMENSION
                        )
                    )
                    resolvedReference.isValidColor() -> resourceList.add(
                        Resource(
                            resolvedResKey,
                            resolvedReference,
                            ResourceType.COLOR
                        )
                    )
                    resolvedReference.isValidTypographyStyle() -> resourceList.add(
                        Resource(
                            resolvedResKey,
                            resolvedReference,
                            ResourceType.STYLE
                        )
                    )
                    values.isValidEnum() -> resourceList.add(
                        Resource(
                            resolvedResKey,
                            resolvedReference,
                            ResourceType.INTEGER
                        )
                    )
                    values.isValidMask() -> parseMaskReference(
                        resolvedResKey,
                        values
                    ).also { resourceList.add(it) }
                    values.isValidMetricRef() -> parseMetricReference(
                        resolvedResKey,
                        values
                    )?.also { resourceList.add(it) }
                    values.isValidTimingFunction() -> generateInterpolator(resolvedResKey, values)
                    Regex(CompositePrimitiveType.ICON.pattern).matches(values) -> {
                        // for icons, make sure the iconName is one of those defined in our enum
                        parsePrimitiveString(
                            resolvedResKey,
                            CompositePrimitiveType.ICON,
                            values
                        ).also { resourceList.addAll(it) }
                    }
                    Regex(CompositePrimitiveType.INSETS.pattern).matches(values) ->
                        resourceList.addAll(
                            parsePrimitiveString(
                                resolvedResKey,
                                CompositePrimitiveType.INSETS,
                                values
                            )
                        )
                    Regex(CompositePrimitiveType.SIZE.pattern).matches(values) ->
                        resourceList.addAll(
                            parsePrimitiveString(
                                resolvedResKey,
                                CompositePrimitiveType.SIZE,
                                values
                            )
                        )
                    Regex(CompositePrimitiveType.RECT.pattern).matches(values) ->
                        resourceList.addAll(
                            parsePrimitiveString(
                                resolvedResKey,
                                CompositePrimitiveType.RECT,
                                values
                            )
                        )
                    Regex(CompositePrimitiveType.FLUENTUICOLOR.pattern).matches(values) -> {
                        val foundValues = Regex(STRING_PATTERN).findAll(values)
                        foundValues.forEachIndexed { _, result ->
                            val colorMap = result.value.split(",").associate {
                                val (left, right) = it.split(":")
                                left.trim() to right.trim()
                            }

                            // Capture both light and dark color variants in a single pass.
                            colorMap["light"]?.let {
                                resourceList.add(
                                    Resource(
                                        resolvedResKey,
                                        it.trim().autoResolveReference(),
                                        ResourceType.COLOR
                                    )
                                )
                            }
                            // Dark theme colors are flagged for night theme so that they will
                            // be written to the night res directory.
                            colorMap["dark"]?.let {
                                resourceList.add(
                                    Resource(
                                        resolvedResKey,
                                        it.trim().autoResolveReference(),
                                        ResourceType.COLOR,
                                        forNightTheme = true
                                    )
                                )
                            }
                        }
                    }
                    Regex(CompositePrimitiveType.NAMEDCOLOR.pattern).matches(values) -> {
                        //  Support for legacy color mappings.
                        Regex(CompositePrimitiveType.NAMEDCOLOR.contentPattern).find(values)?.let { namedColor ->
                            resourceList.add(
                                Resource(
                                    resolvedResKey,
                                    "@color/fluent_${namedColor.value.toLowerCase(Locale.ENGLISH)}",
                                    ResourceType.COLOR
                                )
                            )
                        }
                    }
                    Regex(CompositePrimitiveType.FONT.pattern).matches(values) -> {
                        Regex(CompositePrimitiveType.FONT.contentPattern).findAll(values).forEach {
                            // FIXME: Parse inline Font declarations
                        }
                    }
                    else -> println("Parse Resource, ignoring $resKey: $values")
                }
            }
            is Double -> resourceList.add(Resource(resKey, values.toString(), ResourceType.FLOAT))
            is Int -> resourceList.add(Resource(resKey, values.toString(), ResourceType.INTEGER))
            is Boolean -> resourceList.add(
                Resource(
                    resKey,
                    values.toString(),
                    ResourceType.BOOLEAN
                )
            )
            else -> Unit
        }
    } else printWarning("Invalid resource key \"$resKey\"")
}

// FIXME: Does this need to cover all the same types as parseResource?
fun parseResourceCodeWrapper(resourceList: MutableList<Resource>, resKey: String, values: Any?) {
    if (resKey.isValidKey()) {
        when (values) {
            is ArrayList<*> -> {
                for (v in values) parseResourceCodeWrapper(resourceList, resKey, v)
            }
            is LinkedHashMap<*, *> -> {
                // check if the key is an compile-time expression modifier
                val expressions = values.filter { isResourceExpressionModifier(it.key.toString()) }
                if (expressions.isNotEmpty()) {
                    if (!values.containsKey("default")) {
                        error("When using compile-time expressions, default value must be provided")
                    }
                    var resolvedValue = values["default"]
                    expressions.forEach {
                        if (resolveResourceExpression(it.key.toString())) {
                            resolvedValue = it.value
                        }
                    }
                    parseResourceCodeWrapper(resourceList, resKey, resolvedValue)
                } else {
                    values.forEach {
                        parseResourceCodeWrapper(
                            resourceList,
                            "${resKey}_${it.key}",
                            it.value
                        )
                    }
                }
            }
            is String -> {
                val resolvedReference = values.autoResolveReference().toProgrammatic()
                when {
                    resolvedReference.isValidProgrammaticColor() -> resourceList.add(
                        Resource(
                            resKey,
                            resolvedReference,
                            ResourceType.COLOR
                        )
                    )
                    resolvedReference.isValidProgrammaticStyle() -> resourceList.add(
                        Resource(
                            resKey,
                            resolvedReference,
                            ResourceType.STYLE
                        )
                    )
                    resolvedReference.isValidProgrammaticDimension() -> resourceList.add(
                        Resource(
                            resKey,
                            resolvedReference,
                            ResourceType.DIMENSION
                        )
                    )

                    values.isValidFloat() -> resourceList.add(
                        Resource(
                            resKey,
                            values.rawValue(),
                            ResourceType.FLOAT
                        )
                    )
                    values.isValidDimension() -> resourceList.add(
                        Resource(
                            resKey,
                            values.rawValue(),
                            ResourceType.DIMENSION
                        )
                    )
                    values.isValidEnum() -> resourceList.add(
                        Resource(
                            resKey,
                            resolvedReference,
                            ResourceType.ENUM
                        )
                    )
                    Regex(CompositePrimitiveType.INSETS.pattern).matches(values) ->
                        resourceList.addAll(
                            parsePrimitiveString(
                                resKey,
                                CompositePrimitiveType.INSETS,
                                values
                            )
                        )
                    else -> println("Parse Resource Wrapper, ignoring $resKey: $values")
                }
            }
            is Double -> resourceList.add(Resource(resKey, values.toString(), ResourceType.FLOAT))
            is Int -> resourceList.add(Resource(resKey, values.toString(), ResourceType.INTEGER))
            is Boolean -> resourceList.add(
                Resource(
                    resKey,
                    values.toString(),
                    ResourceType.BOOLEAN
                )
            )
        }
    } else printWarning("Invalid resource key \"$resKey\"")
}

fun isResourceExpressionModifier(key: String) =
    RESOURCE_EXPRESSION_PATTERN.toPattern().matcher(key).matches()

fun resolveResourceExpression(key: String): Boolean {
    RESOURCE_EXPRESSION_PATTERN.toPattern().matcher(key).apply {
        if (matches()) {
            val left = group(1).toLowerCase(Locale.ENGLISH)
            val compare = group(2).toLowerCase(Locale.ENGLISH)
            val right = group(3).toLowerCase(Locale.ENGLISH)
            // TODO: this is simple because we need to cover one scenario for now.
            //  This should be extended to support more logical expressions
            if ((left == "platform" && compare == "=" && right == "android")
                || (left == "platform" && compare == "!=" && right != "android")
            ) {
                return true
            }
            // return false for unrecognized expressions
            return false
        }
    }
    // no expression - return true
    return true
}

fun parsePrimitiveString(
        primitiveKey: String,
        type: CompositePrimitiveType,
        content: String
): MutableList<Resource> {
    val resourceMap = mutableListOf<Resource>()
    val values = Regex(type.contentPattern).findAll(content)
    values.forEachIndexed { index, it ->
        val key = "${primitiveKey}_${type.mask[index]}"
        val formattedValue =
            if (type.resourceType == ResourceType.STRING && type != CompositePrimitiveType.ICON)
                it.value.toJavaEnumValueName()
            else
                it.value

        resourceMap.add(Resource(key, formattedValue, type.resourceType))
    }
    return resourceMap
}

// TODO: Handle multiple option cases Option(value1, value2),
//  for now treating it as an Enum (so only 1 option)
fun parseMaskReference(primitiveKey: String, value: String): Resource =
    Resource(primitiveKey, value.autoResolveReference(), ResourceType.INTEGER)


fun parseMetricReference(primitiveKey: String, value: String): Resource? {
    val metricKey = value.toAndroidReference().decapitalize()
    val metricType = global_getResourceType(metricKey)
    val metricValue = value.autoResolveReference()

    return metricType?.run { Resource(primitiveKey, metricValue, metricType) }
}